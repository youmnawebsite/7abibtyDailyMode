const express = require('express');
const bodyParser = require('body-parser');
const { Pool } = require('pg');
const path = require('path');
const multer = require('multer');
const fs = require('fs');

// ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÖÿ¨ŸÑÿØ uploads
const uploadsDir = path.join(__dirname, 'uploads');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
  console.log('‚úÖ Created uploads directory');
}

// ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÖÿ¨ŸÑÿØ backups
const backupsDir = path.join(__dirname, 'backups');
if (!fs.existsSync(backupsDir)) {
  fs.mkdirSync(backupsDir, { recursive: true });
  console.log('‚úÖ Created backups directory');
}

// ÿØÿßŸÑÿ© ŸÑÿ•ŸÜÿ¥ÿßÿ° ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ© ŸÖŸÜ ŸÖŸÑŸÅ
function backupFile(sourcePath, fileId) {
  try {
    if (!fs.existsSync(sourcePath)) {
      console.error(`‚ùå Source file does not exist: ${sourcePath}`);
      return false;
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä
    const fileExt = path.extname(sourcePath);
    const backupFileName = `backup_${fileId}_${Date.now()}${fileExt}`;
    const backupPath = path.join(backupsDir, backupFileName);

    // ŸÜÿ≥ÿÆ ÿßŸÑŸÖŸÑŸÅ
    fs.copyFileSync(sourcePath, backupPath);
    console.log(`‚úÖ Backup created: ${backupPath}`);

    return backupFileName;
  } catch (err) {
    console.error(`‚ùå Error creating backup: ${err}`);
    return false;
  }
}

const app = express();
const port = process.env.PORT || 8080;
const storage = multer.diskStorage({
  destination: 'uploads/',
  filename: (req, file, cb) => {
    // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÖÿ™ÿØÿßÿØ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ£ÿµŸÑŸä ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÖÿ™ÿØÿßÿØ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿµŸàÿ™Ÿäÿ©
    let ext = path.extname(file.originalname);
    if (!ext && file.mimetype.startsWith('audio/')) {
      // ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸáŸÜÿßŸÉ ÿßŸÖÿ™ÿØÿßÿØ ŸàŸÑŸÉŸÜŸá ŸÖŸÑŸÅ ÿµŸàÿ™Ÿäÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿßŸÖÿ™ÿØÿßÿØ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
      if (file.mimetype.includes('webm')) {
        ext = '.webm';
      } else if (file.mimetype.includes('wav')) {
        ext = '.wav';
      } else {
        ext = '.audio'; // ÿßŸÖÿ™ÿØÿßÿØ ÿπÿßŸÖ ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä
      }
    }
    cb(null, file.fieldname + '-' + Date.now() + ext);
  },
});

// ÿ™ÿπŸäŸäŸÜ ÿ≠ÿØŸàÿØ ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ ŸàÿÆŸäÿßÿ±ÿßÿ™ ÿ£ÿÆÿ±Ÿâ
const upload = multer({
  storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ 10 ŸÖŸäÿ¨ÿßÿ®ÿßŸäÿ™
  }
});

// Middleware
app.use(bodyParser.json());
app.use(express.static('public'));

// PostgreSQL Connection
const pool = new Pool({
  connectionString: "postgresql://postgres.mnaisebumwnrjewtdzmh:GIx5bTNAJ9Pf3W5A@aws-0-us-east-1.pooler.supabase.com:6543/postgres",
  ssl: { rejectUnauthorized: false }
});

pool.query("SELECT NOW()", (err, res) => {
  if (err) {
    console.error("‚ùå Error connecting to database:", err);
  } else {
    console.log("‚úÖ Database connected successfully at:", res.rows[0].now);
  }
});

// Serve Admin Page
app.get('/admin', (req, res) => {
  res.sendFile(path.join(__dirname, 'admin.html'));
});

// Fetch all responses
app.get('/responses', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM responses ORDER BY timestamp DESC');
    res.json(result.rows);
  } catch (err) {
    console.error('‚ùå Error fetching responses:', err);
    res.status(500).json({ error: 'Error fetching responses' });
  }
});

// Submit a new response
app.post('/submit', upload.single('audio'), async (req, res) => {
  try {
    console.log('üìù Received submission request');
    console.log('üìù Request body:', req.body);

    const { question, answer } = req.body;

    if (!question) {
      console.error('‚ùå Question is missing in the request');
      return res.status(400).send('Question is required');
    }

    let finalAnswer = answer || null; // ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑŸÜÿµŸäÿ©

    if (req.file) {
      // ÿ™ÿ≥ÿ¨ŸäŸÑ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖŸÑŸÅ ŸÑŸÑÿ™ÿ¥ÿÆŸäÿµ
      console.log('üéµ Audio file received:', {
        filename: req.file.filename,
        originalname: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size,
        path: req.file.path
      });

      // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖÿ¨ŸÑÿØ
      if (!fs.existsSync(req.file.path)) {
        console.error('‚ùå File was not saved correctly:', req.file.path);
      } else {
        console.log('‚úÖ File exists at path:', req.file.path);
      }

      finalAnswer = `/uploads/${req.file.filename}`; // ÿ•ÿ∞ÿß ŸàŸèÿ¨ÿØ ŸÖŸÑŸÅ ÿµŸàÿ™Ÿä
    } else {
      console.log('üìù No audio file in the request');
    }

    console.log('üìù Saving to database:', { question, finalAnswer });

    // ÿ•ÿØÿ±ÿßÿ¨ ÿßŸÑÿ±ÿØ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    const result = await pool.query(
      'INSERT INTO responses (question, answer, timestamp) VALUES ($1, $2, NOW()) RETURNING *',
      [question, finalAnswer]
    );

    const responseId = result.rows[0].id;
    console.log('‚úÖ Response saved successfully:', result.rows[0]);

    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ±ÿØ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖŸÑŸÅ ÿµŸàÿ™Ÿäÿå ŸÇŸÖ ÿ®ÿ•ŸÜÿ¥ÿßÿ° ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
    if (finalAnswer && finalAnswer.startsWith('/uploads/')) {
      const filePath = path.join(__dirname, finalAnswer.substring(1));

      if (fs.existsSync(filePath)) {
        // ÿ•ŸÜÿ¥ÿßÿ° ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
        const backupFileName = backupFile(filePath, responseId);

        if (backupFileName) {
          console.log(`‚úÖ Backup created for file: ${backupFileName}`);

          // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≥ÿ¨ŸÑ ÿ®ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÜÿ≥ÿÆÿ© ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
          await pool.query(
            'ALTER TABLE responses ADD COLUMN IF NOT EXISTS backup_path TEXT'
          );

          await pool.query(
            'UPDATE responses SET backup_path = $1 WHERE id = $2',
            [`/backups/${backupFileName}`, responseId]
          );
        }
      } else {
        console.error(`‚ùå Audio file not found for backup: ${filePath}`);
      }
    }

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ®ÿ≥Ÿäÿ∑ÿ© ŸÑÿ™ÿ¨ŸÜÿ® ŸÖÿ¥ÿßŸÉŸÑ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸä ÿßŸÑÿπŸÖŸäŸÑ
    res.status(200).send('OK');
  } catch (err) {
    console.error('‚ùå Error saving response:', err);
    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ®ÿ≥Ÿäÿ∑ÿ© ŸÑÿ™ÿ¨ŸÜÿ® ŸÖÿ¥ÿßŸÉŸÑ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸä ÿßŸÑÿπŸÖŸäŸÑ
    res.status(500).send('Error');
  }
});

// ÿ™ŸÉŸàŸäŸÜ ÿÆÿßÿµ ŸÑŸÖÿ¨ŸÑÿØ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑÿßÿ™
app.use('/uploads', express.static(path.join(__dirname, 'uploads'), {
  setHeaders: (res, filePath) => {
    console.log('üìÅ Serving file:', filePath);

    // ÿ™ÿπŸäŸäŸÜ ÿ±ÿ§Ÿàÿ≥ HTTP ŸÑŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿµŸàÿ™Ÿäÿ©
    if (filePath.endsWith('.mp3')) {
      res.setHeader('Content-Type', 'audio/mpeg');
    } else if (filePath.endsWith('.wav')) {
      res.setHeader('Content-Type', 'audio/wav');
    } else if (filePath.endsWith('.ogg')) {
      res.setHeader('Content-Type', 'audio/ogg');
    } else if (filePath.endsWith('.webm')) {
      res.setHeader('Content-Type', 'audio/webm');
    } else if (filePath.endsWith('.audio')) {
      res.setHeader('Content-Type', 'audio/mpeg'); // ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
    }

    // ÿ™ÿπŸäŸäŸÜ ÿ±ÿ§Ÿàÿ≥ CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');

    // ÿ™ÿπŸäŸäŸÜ ÿ±ÿ§Ÿàÿ≥ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™
    res.setHeader('Cache-Control', 'public, max-age=31536000');

    // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
    res.setHeader('Content-Disposition', 'inline');
  }
}));

// ÿ™ŸÉŸàŸäŸÜ ÿÆÿßÿµ ŸÑŸÖÿ¨ŸÑÿØ ÿßŸÑŸÜÿ≥ÿÆ ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
app.use('/backups', express.static(path.join(__dirname, 'backups'), {
  setHeaders: (res, filePath) => {
    console.log('üìÅ Serving backup file:', filePath);

    // ÿ™ÿπŸäŸäŸÜ ÿ±ÿ§Ÿàÿ≥ HTTP ŸÑŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿµŸàÿ™Ÿäÿ©
    if (filePath.endsWith('.mp3')) {
      res.setHeader('Content-Type', 'audio/mpeg');
    } else if (filePath.endsWith('.wav')) {
      res.setHeader('Content-Type', 'audio/wav');
    } else if (filePath.endsWith('.ogg')) {
      res.setHeader('Content-Type', 'audio/ogg');
    } else if (filePath.endsWith('.webm')) {
      res.setHeader('Content-Type', 'audio/webm');
    } else if (filePath.endsWith('.audio')) {
      res.setHeader('Content-Type', 'audio/mpeg'); // ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
    }

    // ÿ™ÿπŸäŸäŸÜ ÿ±ÿ§Ÿàÿ≥ CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');

    // ÿ™ÿπŸäŸäŸÜ ÿ±ÿ§Ÿàÿ≥ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™
    res.setHeader('Cache-Control', 'public, max-age=31536000');

    // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
    res.setHeader('Content-Disposition', 'inline');
  }
}));

// Delete a response by ID
app.delete('/responses/:id', async (req, res) => {
  try {
    const id = req.params.id;
    await pool.query('DELETE FROM responses WHERE id = $1', [id]);
    res.status(200).json({ message: '‚úÖ Response deleted successfully' });
  } catch (err) {
    console.error('‚ùå Error deleting response:', err);
    res.status(500).json({ error: 'Failed to delete response' });
  }
});

// Update a response by ID
app.put('/responses/:id', async (req, res) => {
  try {
    const id = req.params.id;
    const { answer, timestamp } = req.body;

    if (!answer) {
      return res.status(400).json({ error: 'Answer is required' });
    }

    if (timestamp) {
      await pool.query('UPDATE responses SET answer = $1, timestamp = $2 WHERE id = $3', [
        answer,
        timestamp,
        id,
      ]);
    } else {
      await pool.query('UPDATE responses SET answer = $1 WHERE id = $2', [answer, id]);
    }

    res.status(200).json({ message: '‚úÖ Response updated successfully' });
  } catch (err) {
    console.error('‚ùå Error updating response:', err);
    res.status(500).json({ error: 'Failed to update response' });
  }
});

// ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ÿØŸàŸÑ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
async function createRemindersTable() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS reminders (
        id SERIAL PRIMARY KEY,
        time TIME NOT NULL,
        message TEXT NOT NULL,
        method VARCHAR(20) NOT NULL,
        email VARCHAR(100),
        active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('‚úÖ Reminders table created or already exists');
  } catch (err) {
    console.error('‚ùå Error creating reminders table:', err);
  }
}

// ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ÿØŸàŸÑ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™ ÿπŸÜÿØ ÿ®ÿØÿ° ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ
createRemindersTable();

// API ŸÑÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™
app.post('/reminders', async (req, res) => {
  try {
    console.log('üìù Received reminder request:', req.body);

    const { time, message, method, email } = req.body;

    if (!time || !message || !method) {
      console.error('‚ùå Missing required fields:', { time, message, method });
      return res.status(400).json({ error: 'Missing required fields' });
    }

    if (method === 'email' && !email) {
      console.error('‚ùå Email is required for email reminders');
      return res.status(400).json({ error: 'Email is required for email reminders' });
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ¨ÿØŸàŸÑ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™
    try {
      await pool.query('SELECT 1 FROM reminders LIMIT 1');
    } catch (tableErr) {
      console.error('‚ùå Reminders table might not exist, creating it now...');
      await createRemindersTable();
    }

    // ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ± ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    console.log('üìù Saving reminder to database:', { time, message, method, email: email || null });

    const result = await pool.query(
      'INSERT INTO reminders (time, message, method, email) VALUES ($1, $2, $3, $4) RETURNING *',
      [time, message, method, email || null]
    );

    console.log('‚úÖ Reminder saved successfully:', result.rows[0]);

    res.status(200).json({
      message: 'Reminder saved successfully',
      reminder: result.rows[0]
    });
  } catch (err) {
    console.error('‚ùå Error saving reminder:', err);

    // ŸÖÿπÿßŸÑÿ¨ÿ© ÿ£ŸÉÿ´ÿ± ÿ™ŸÅÿµŸäŸÑÿßŸã ŸÑŸÑÿ£ÿÆÿ∑ÿßÿ°
    if (err.code === '42P01') {
      // ÿ¨ÿØŸàŸÑ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ
      try {
        await createRemindersTable();
        return res.status(500).json({ error: 'Table was missing but has been created. Please try again.' });
      } catch (createErr) {
        console.error('‚ùå Error creating reminders table:', createErr);
        return res.status(500).json({ error: 'Failed to create reminders table' });
      }
    } else if (err.code === '23505') {
      // ÿ™ÿπÿßÿ±ÿ∂ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä
      return res.status(400).json({ error: 'A reminder with this ID already exists' });
    } else {
      res.status(500).json({ error: 'Failed to save reminder' });
    }
  }
});

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™
app.get('/reminders', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM reminders ORDER BY time');
    res.json(result.rows);
  } catch (err) {
    console.error('‚ùå Error fetching reminders:', err);
    res.status(500).json({ error: 'Failed to fetch reminders' });
  }
});

// ÿ≠ÿ∞ŸÅ ÿ™ÿ∞ŸÉŸäÿ±
app.delete('/reminders/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await pool.query('DELETE FROM reminders WHERE id = $1', [id]);
    res.status(200).json({ message: 'Reminder deleted successfully' });
  } catch (err) {
    console.error('‚ùå Error deleting reminder:', err);
    res.status(500).json({ error: 'Failed to delete reminder' });
  }
});

// ÿ™ÿ®ÿØŸäŸÑ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ∞ŸÉŸäÿ± (ŸÜÿ¥ÿ∑/ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑)
app.put('/reminders/:id/toggle', async (req, res) => {
  try {
    const { id } = req.params;
    const { active } = req.body;

    if (active === undefined) {
      return res.status(400).json({ error: 'Active status is required' });
    }

    await pool.query('UPDATE reminders SET active = $1 WHERE id = $2', [active, id]);
    res.status(200).json({ message: 'Reminder status updated successfully' });
  } catch (err) {
    console.error('‚ùå Error updating reminder status:', err);
    res.status(500).json({ error: 'Failed to update reminder status' });
  }
});

// ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±
app.post('/reminders/:id/test', async (req, res) => {
  try {
    const { id } = req.params;

    // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±
    const result = await pool.query('SELECT * FROM reminders WHERE id = $1', [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Reminder not found' });
    }

    const reminder = result.rows[0];

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±
    if (reminder.method === 'notification') {
      // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßÿ¥ÿ™ÿ±ÿßŸÉÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
      const subscriptionsResult = await pool.query('SELECT * FROM push_subscriptions');

      let sent = false;
      for (const sub of subscriptionsResult.rows) {
        try {
          const subscription = JSON.parse(sub.subscription);
          const success = await sendNotification(subscription, reminder.message);
          if (success) {
            sent = true;
          }
        } catch (err) {
          console.error('‚ùå Error parsing subscription:', err);
        }
      }

      if (!sent && subscriptionsResult.rows.length > 0) {
        return res.status(500).json({ error: 'Failed to send notification' });
      }

      if (subscriptionsResult.rows.length === 0) {
        return res.status(400).json({ error: 'No push subscriptions found' });
      }
    } else if (reminder.method === 'email' && reminder.email) {
      const success = await sendEmail(reminder.email, reminder.message);

      if (!success) {
        return res.status(500).json({ error: 'Failed to send email' });
      }
    } else {
      return res.status(400).json({ error: 'Invalid reminder method' });
    }

    res.status(200).json({ message: 'Reminder sent successfully' });
  } catch (err) {
    console.error('‚ùå Error testing reminder:', err);
    res.status(500).json({ error: 'Failed to test reminder' });
  }
});

// ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ÿØŸàŸÑ ÿßÿ¥ÿ™ÿ±ÿßŸÉÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØŸãÿß
async function createSubscriptionsTable() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS push_subscriptions (
        id SERIAL PRIMARY KEY,
        subscription TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('‚úÖ Push subscriptions table created or already exists');
  } catch (err) {
    console.error('‚ùå Error creating push subscriptions table:', err);
  }
}

// ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ÿØŸàŸÑ ÿßÿ¥ÿ™ÿ±ÿßŸÉÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿπŸÜÿØ ÿ®ÿØÿ° ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ
createSubscriptionsTable();

// API ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠
app.get('/push-subscription', (req, res) => {
  res.json({
    publicKey: 'BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U'
  });
});

// ÿ™ÿÆÿ≤ŸäŸÜ ÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
app.post('/push-subscription', async (req, res) => {
  try {
    const subscription = req.body;

    if (!subscription) {
      return res.status(400).json({ error: 'Subscription data is required' });
    }

    // ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    await pool.query(
      'INSERT INTO push_subscriptions (subscription) VALUES ($1)',
      [JSON.stringify(subscription)]
    );

    res.status(200).json({ message: 'Subscription saved successfully' });
  } catch (err) {
    console.error('‚ùå Error saving subscription:', err);
    res.status(500).json({ error: 'Failed to save subscription' });
  }
});

// ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ±
async function sendNotification(subscription, message) {
  try {
    const webpush = require('web-push');

    // ÿ™ŸÉŸàŸäŸÜ ŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
    webpush.setVapidDetails(
      'mailto:example@example.com',
      'BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U',
      'Xpo8WrhQDLcfo1LrYFST-y1qXd_qVYJQQyJUUN7i0Ns'
    );

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
    await webpush.sendNotification(
      subscription,
      JSON.stringify({
        title: 'ÿ™ÿ∞ŸÉŸäÿ± ŸÖŸÜ ŸÖŸàŸÇÿπ ÿ≠ÿ®Ÿäÿ®ÿ™Ÿä',
        body: message,
        icon: '/icon.png'
      })
    );

    console.log('‚úÖ Notification sent successfully');
    return true;
  } catch (err) {
    console.error('‚ùå Error sending notification:', err);
    return false;
  }
}

// ÿ•ÿ±ÿ≥ÿßŸÑ ÿ®ÿ±ŸäÿØ ÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
async function sendEmail(email, message) {
  try {
    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖŸÉÿ™ÿ®ÿ© nodemailer ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
    const nodemailer = require('nodemailer');

    // ÿ•ŸÜÿ¥ÿßÿ° ŸÜÿßŸÇŸÑ ÿ®ÿ±ŸäÿØ ÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿÆÿØŸÖÿ© Gmail
    // ŸÖŸÑÿßÿ≠ÿ∏ÿ©: ŸÅŸä ÿ®Ÿäÿ¶ÿ© ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ÿå Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿ®Ÿäÿ¶Ÿäÿ© ŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿßÿπÿ™ŸÖÿßÿØ
    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: 'mazenyousseff2@gmail.com', // ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿ®ÿπŸÜŸàÿßŸÜ ÿ®ÿ±ŸäÿØŸÉ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
        pass: '' // ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿ®ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ (ŸÑŸäÿ≥ ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿ≠ÿ≥ÿßÿ®ŸÉ)
      }
    });

    // ÿ•ÿπÿØÿßÿØ ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
    const mailOptions = {
      from: 'mazenyousseff2@gmail.com', // ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿ®ÿπŸÜŸàÿßŸÜ ÿ®ÿ±ŸäÿØŸÉ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
      to: email,
      subject: 'ÿ™ÿ∞ŸÉŸäÿ± ŸÖŸÜ ŸÖŸàŸÇÿπ ÿ≠ÿ®Ÿäÿ®ÿ™Ÿä',
      text: message,
      html: `
        <div dir="rtl" style="font-family: Arial, sans-serif; padding: 20px; background-color: #f9f9f9; border-radius: 10px;">
          <h2 style="color: #e91e63;">ÿ™ÿ∞ŸÉŸäÿ± ŸÖŸÜ ŸàŸäÿ®ÿ≥ÿßŸäÿ™ ÿ≠ÿ®Ÿäÿ®ÿ™Ÿä</h2>
          <p style="font-size: 16px; color: #333;">${message}</p>
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd;">
            <p style="font-size: 14px; color: #777;">ÿØŸá ÿ™ÿ∞ŸÉŸäÿ± ÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÖŸÜ ŸàŸäÿ®ÿ≥ÿßŸäÿ™ ÿ≠ÿ®Ÿäÿ®ÿ™Ÿä </p>
          </div>
        </div>
      `
    };

    // ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿå ÿ≥ŸÜŸÇŸàŸÖ ŸÅŸÇÿ∑ ÿ®ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß ŸÅÿπŸÑŸäŸãÿß
    // ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ŸÅÿπŸÑŸäŸãÿßÿå ŸÇŸÖ ÿ®ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ÿπŸÑŸäŸÇ ÿπŸÜ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ™ÿßŸÑŸä
    // Ÿàÿ™ŸÉŸàŸäŸÜ ÿ®ŸäÿßŸÜÿßÿ™ ÿßÿπÿ™ŸÖÿßÿØ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿßŸÑÿÆÿßÿµÿ© ÿ®ŸÉ

    /*
    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä
    const info = await transporter.sendMail(mailOptions);
    console.log('‚úÖ Email sent:', info.messageId);
    */

    // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÅŸÇÿ∑ (ŸÑŸÑÿßÿÆÿ™ÿ®ÿßÿ±)
    console.log(`‚úÖ Email would be sent to ${email}: ${message}`);

    return true;
  } catch (err) {
    console.error('‚ùå Error sending email:', err);
    return false;
  }
}

// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™ Ÿàÿ•ÿ±ÿ≥ÿßŸÑŸáÿß
async function checkAndSendReminders() {
  try {
    // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä
    const now = new Date();
    const currentTime = now.toTimeString().substring(0, 5); // HH:MM

    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™ ÿßŸÑÿ™Ÿä Ÿäÿ¨ÿ® ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß
    const result = await pool.query(
      'SELECT * FROM reminders WHERE time = $1 AND active = TRUE',
      [currentTime]
    );

    if (result.rows.length === 0) {
      return;
    }

    console.log(`üîî Found ${result.rows.length} reminders to send at ${currentTime}`);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ŸÉŸÑ ÿ™ÿ∞ŸÉŸäÿ±
    for (const reminder of result.rows) {
      if (reminder.method === 'notification') {
        // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßÿ¥ÿ™ÿ±ÿßŸÉÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
        const subscriptionsResult = await pool.query('SELECT * FROM push_subscriptions');

        for (const sub of subscriptionsResult.rows) {
          try {
            const subscription = JSON.parse(sub.subscription);
            await sendNotification(subscription, reminder.message);
          } catch (err) {
            console.error('‚ùå Error parsing subscription:', err);
          }
        }
      } else if (reminder.method === 'email' && reminder.email) {
        await sendEmail(reminder.email, reminder.message);
      }
    }
  } catch (err) {
    console.error('‚ùå Error checking reminders:', err);
  }
}

// ÿ™ÿ¥ÿ∫ŸäŸÑ ŸÅÿ≠ÿµ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™ ŸÉŸÑ ÿØŸÇŸäŸÇÿ©
setInterval(checkAndSendReminders, 60000);

// ÿ•ÿπÿßÿØÿ© ÿ™ÿ±ÿ™Ÿäÿ® ÿ¨ŸÖŸäÿπ ÿßŸÑŸÄ IDs
app.post('/reorder-ids', async (req, res) => {
  try {
    const { updates } = req.body;

    if (!updates || !Array.isArray(updates)) {
      // ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ŸàŸÅŸäÿ± ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ÿå ŸÇŸÖ ÿ®ÿ•ÿπÿßÿØÿ© ÿ™ÿ±ÿ™Ÿäÿ® ÿ¨ŸÖŸäÿπ ÿßŸÑŸÄ IDs ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß
      return await reorderAllIds(req, res);
    }

    // ÿ®ÿØÿ° ŸÖÿπÿßŸÖŸÑÿ© ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ÿØŸàŸÑ ŸÖÿ§ŸÇÿ™ ŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™
      await client.query(`
        CREATE TEMP TABLE id_updates (
          old_id INTEGER,
          new_id INTEGER
        )
      `);

      // ÿ•ÿØÿ±ÿßÿ¨ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ŸÅŸä ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸÖÿ§ŸÇÿ™
      for (const update of updates) {
        await client.query('INSERT INTO id_updates (old_id, new_id) VALUES ($1, $2)', [
          update.id,
          update.newId
        ]);
      }

      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÄ IDs ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸÖÿ§ŸÇÿ™
      await client.query(`
        UPDATE responses
        SET id = id_updates.new_id
        FROM id_updates
        WHERE responses.id = id_updates.old_id
      `);

      // ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ÿ™ÿ≥ŸÑÿ≥ŸÑ ÿßŸÑŸÄ ID
      const maxIdResult = await client.query('SELECT MAX(id) FROM responses');
      const maxId = maxIdResult.rows[0].max || 0;

      // ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ÿ™ÿ≥ŸÑÿ≥ŸÑ ÿßŸÑŸÄ ID
      await client.query(`ALTER SEQUENCE responses_id_seq RESTART WITH ${maxId + 1}`);

      await client.query('COMMIT');
      res.status(200).json({ message: 'IDs reordered successfully' });
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  } catch (err) {
    console.error('‚ùå Error reordering IDs:', err);
    res.status(500).json({ error: 'Failed to reorder IDs' });
  }
});

// ÿ•ÿπÿßÿØÿ© ÿ™ÿ±ÿ™Ÿäÿ® ÿ¨ŸÖŸäÿπ ÿßŸÑŸÄ IDs ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß
async function reorderAllIds(req, res) {
  try {
    // ÿ®ÿØÿ° ŸÖÿπÿßŸÖŸÑÿ© ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿØŸàÿØ ŸÖÿ±ÿ™ÿ®ÿ© ÿ≠ÿ≥ÿ® ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
      const result = await client.query('SELECT id FROM responses ORDER BY timestamp');
      const responses = result.rows;

      if (responses.length === 0) {
        await client.query('COMMIT');

        if (res) {
          res.status(200).json({
            message: 'No responses to reorder',
            count: 0
          });
        }

        return true;
      }

      // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ∑ÿ±ŸäŸÇÿ© ÿ£ŸÉÿ´ÿ± ÿ£ŸÖÿßŸÜŸãÿß ŸÑÿ•ÿπÿßÿØÿ© ÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑŸÄ IDs
      // ÿ£ŸàŸÑÿßŸãÿå ŸÜŸÇŸàŸÖ ÿ®ÿ™ÿ≠ÿØŸäÿ´ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÄ IDs ÿ•ŸÑŸâ ŸÇŸäŸÖ ÿ≥ÿßŸÑÿ®ÿ© ŸÖÿ§ŸÇÿ™ÿ© ŸÑÿ™ÿ¨ŸÜÿ® ÿ™ÿπÿßÿ±ÿ∂ÿßÿ™ ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
      for (let i = 0; i < responses.length; i++) {
        await client.query('UPDATE responses SET id = $1 WHERE id = $2', [
          -(i + 1), // ŸÇŸäŸÖÿ© ÿ≥ÿßŸÑÿ®ÿ© ŸÖÿ§ŸÇÿ™ÿ©
          responses[i].id
        ]);
      }

      // ÿ´ŸÖ ŸÜŸÇŸàŸÖ ÿ®ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÄ IDs ÿ•ŸÑŸâ ÿßŸÑŸÇŸäŸÖ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ÿßŸÑŸÖŸàÿ¨ÿ®ÿ©
      for (let i = 0; i < responses.length; i++) {
        await client.query('UPDATE responses SET id = $1 WHERE id = $2', [
          i + 1, // ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©
          -(i + 1)
        ]);
      }

      // ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ÿ™ÿ≥ŸÑÿ≥ŸÑ ÿßŸÑŸÄ ID
      await client.query(`ALTER SEQUENCE responses_id_seq RESTART WITH ${responses.length + 1}`);

      await client.query('COMMIT');

      if (res) {
        res.status(200).json({
          message: 'All IDs reordered successfully',
          count: responses.length
        });
      }

      return true;
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  } catch (err) {
    console.error('‚ùå Error reordering all IDs:', err);

    if (res) {
      res.status(500).json({ error: 'Failed to reorder all IDs' });
    }

    return false;
  }
}

// ÿ•ÿπÿßÿØÿ© ÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑŸÄ IDs ÿπŸÜÿØ ÿ®ÿØÿ° ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ
setTimeout(async () => {
  try {
    console.log('üîÑ Reordering IDs on startup...');
    await reorderAllIds();
    console.log('‚úÖ IDs reordered successfully');
  } catch (err) {
    console.error('‚ùå Error reordering IDs on startup:', err);
  }
}, 5000); // ÿßŸÜÿ™ÿ∏ÿ± 5 ÿ´ŸàÿßŸÜŸç ÿ®ÿπÿØ ÿ®ÿØÿ° ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ

// API ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑÿßÿ™ ÿßŸÑÿµŸàÿ™Ÿäÿ©
app.get('/check-audio-files', async (req, res) => {
  try {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    const result = await pool.query('SELECT id, question, answer, timestamp, backup_path FROM responses WHERE answer LIKE \'/uploads/%\'');

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖŸÑŸÅÿßÿ™
    const audioResponses = result.rows;
    const fileStatus = [];

    for (const response of audioResponses) {
      const filePath = path.join(__dirname, response.answer.substring(1)); // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ¥ÿ±ÿ∑ÿ© ÿßŸÑŸÖÿßÿ¶ŸÑÿ© ÿßŸÑÿ£ŸàŸÑŸâ
      const exists = fs.existsSync(filePath);

      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
      let backupExists = false;
      if (response.backup_path) {
        const backupPath = path.join(__dirname, response.backup_path.substring(1));
        backupExists = fs.existsSync(backupPath);
      }

      fileStatus.push({
        id: response.id,
        path: response.answer,
        exists: exists,
        backup_path: response.backup_path,
        backup_exists: backupExists,
        timestamp: response.timestamp
      });
    }

    res.json({
      totalAudioResponses: audioResponses.length,
      fileStatus: fileStatus
    });
  } catch (err) {
    console.error('‚ùå Error checking audio files:', err);
    res.status(500).json({ error: 'Failed to check audio files' });
  }
});

// API ŸÑÿßÿ≥ÿ™ÿπÿßÿØÿ© ŸÖŸÑŸÅ ŸÖŸÜ ÿßŸÑŸÜÿ≥ÿÆÿ© ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
app.post('/restore-audio/:id', async (req, res) => {
  try {
    const { id } = req.params;

    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ±ÿØ
    const result = await pool.query(
      'SELECT id, answer, backup_path FROM responses WHERE id = $1',
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Response not found' });
    }

    const response = result.rows[0];

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
    if (!response.backup_path) {
      return res.status(404).json({ error: 'No backup found for this response' });
    }

    const backupPath = path.join(__dirname, response.backup_path.substring(1));

    if (!fs.existsSync(backupPath)) {
      return res.status(404).json({ error: 'Backup file not found' });
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ≥ÿßÿ± ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ£ÿµŸÑŸä
    const originalPath = path.join(__dirname, response.answer.substring(1));
    const originalDir = path.dirname(originalPath);

    // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖÿ¨ŸÑÿØ
    if (!fs.existsSync(originalDir)) {
      fs.mkdirSync(originalDir, { recursive: true });
    }

    // ŸÜÿ≥ÿÆ ÿßŸÑŸÖŸÑŸÅ ŸÖŸÜ ÿßŸÑŸÜÿ≥ÿÆÿ© ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
    fs.copyFileSync(backupPath, originalPath);

    res.status(200).json({
      message: 'Audio file restored successfully',
      original_path: response.answer,
      backup_path: response.backup_path
    });
  } catch (err) {
    console.error('‚ùå Error restoring audio file:', err);
    res.status(500).json({ error: 'Failed to restore audio file' });
  }
});

// API ŸÑÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÜÿ≥ÿÆ ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
app.get('/backups', async (req, res) => {
  try {
    // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜÿ≥ÿÆ ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
    const files = fs.readdirSync(backupsDir);

    const backups = files.map(file => {
      const stats = fs.statSync(path.join(backupsDir, file));
      return {
        filename: file,
        path: `/backups/${file}`,
        size: stats.size,
        created: stats.birthtime
      };
    });

    res.json({
      total: backups.length,
      backups: backups
    });
  } catch (err) {
    console.error('‚ùå Error fetching backups:', err);
    res.status(500).json({ error: 'Failed to fetch backups' });
  }
});

// API ŸÑÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿµŸàÿ™Ÿäÿ©
app.get('/test-audio/:filename', (req, res) => {
  try {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, 'uploads', filename);

    console.log('üéµ Testing audio file:', filePath);

    if (!fs.existsSync(filePath)) {
      console.log('‚ùå File not found:', filePath);
      return res.status(404).json({
        error: 'File not found',
        path: filePath,
        exists: false
      });
    }

    const stats = fs.statSync(filePath);
    console.log('‚úÖ File found:', {
      path: filePath,
      size: stats.size,
      modified: stats.mtime
    });

    res.json({
      message: 'File exists and accessible',
      path: filePath,
      size: stats.size,
      modified: stats.mtime,
      exists: true
    });

  } catch (err) {
    console.error('‚ùå Error testing audio file:', err);
    res.status(500).json({ error: 'Error testing file' });
  }
});

// Start the server
app.listen(port, () => {
  console.log(`üöÄ Server is running on port ${port}`);
});
